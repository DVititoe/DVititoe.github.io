\doxysection{Software Architecture}
\hypertarget{_software__architecture}{}\label{_software__architecture}\index{Software Architecture@{Software Architecture}}
\label{_software__architecture_md__c_1_2_users_2david_2_documents_2_platform_i_o_2_solo___controller_2_solo___controller___repo_2docs_2_software___architecture}%
\Hypertarget{_software__architecture_md__c_1_2_users_2david_2_documents_2_platform_i_o_2_solo___controller_2_solo___controller___repo_2docs_2_software___architecture}%
\hypertarget{_software__architecture_autotoc_md34}{}\doxysubsection{\texorpdfstring{Key Software Components}{Key Software Components}}\label{_software__architecture_autotoc_md34}
The following Block Definition Diagram shows the major components of the Solo Controller application. This software is designed to run as a single threaded application.

\begin{center}\end{center} 

The Solo Controller App uses the \href{https://tcmenu.github.io/documentation/arduino-libraries/taskmanager-io/}{\texttt{ Task\+Manger\+IO}} library to schedule tasks to be run on the Mega 2560 controller. This provides a convenient mechanism for managing all the individual tasks used by the application. Tasks can scheduled to run at different rates. So, as an example, user interface tasks can be scheduled to run frequently to ensure the UI is responsive. However, sensor tasks can be read at a slower rate, since these values are expected to change more slowly.

All of the tasks run by Task\+Manger\+IO are run sequentially within a single thread. So, only one object/function/task can be running at any one time. Therefore there is no need to protect the global data structures (temperatures, volume readings, etc) with mutex or semaphore protections.

The various other classes used by the application include\+:


\begin{DoxyItemize}
\item {\bfseries{Temp\+Sensor}}\+: Interface to the PT100 RTD temperature probes
\item {\bfseries{Vol\+Sensor}}\+: Interface to the volume sensor installed in the Kettle
\item {\bfseries{Alarm\+Manage}}\+: Monitors sensor values against set values. Triggers audible alarms when out of bounds. Notifies \doxylink{class_solo_menu}{Solo\+Menu} of alarm conditions
\item {\bfseries{PID\+\_\+\+Manager}}\+: (TBD)
\item {\bfseries{\doxylink{class_solo_menu}{Solo\+Menu}}} Collection of User Interface classes, described in more detail below.
\end{DoxyItemize}

The following object diagram shows how these components interact with one another\+:

\begin{center}\end{center} 

Upon startup, the application will register a number of default tasks with the Task\+Manager. These tasks handle basic functionality such as updating the user interface, reading temperature and volume sensors, and monitoring for alarms.

The user interacts with the application via the TFT touch screen display. If possible, \doxylink{class_solo_menu}{Solo\+Menu} will respond directly to user requests. In some cases, \doxylink{class_solo_menu}{Solo\+Menu} will implement the behavior by sending a new task to Task\+Manager. Some examples of tasks that could be generated by \doxylink{class_solo_menu}{Solo\+Menu}, include turn on/off temperature PIDs and turning on/off the system alarm.

Note that user interface graphics and font imagery is not passed between objects. The SPI interfaces used by the electronics just isn\textquotesingle{}t fast enough to efficiently transfer this data in a timely fashion. Instead, the images uses by the UI are either either stored in TFT ROM or is generated by the TFT/\+LT7683 graphics engine. The resulting images are loaded into TFT RAM, making it available to \doxylink{class_solo_menu}{Solo\+Menu}.\hypertarget{_software__architecture_autotoc_md35}{}\doxysubsection{\texorpdfstring{User Interface Classes}{User Interface Classes}}\label{_software__architecture_autotoc_md35}
The classes that implement the menu system for the Solo Controller app are shown in the following diagram\+:

\begin{center}\end{center} 

\doxylink{class_solo_menu}{Solo\+Menu} is an abstract base used by all menu objects. \doxylink{class_solo_menu}{Solo\+Menu} defines the common methods used by all menu classes. It also provides a basic button management capability. Derived menus just need to register their buttons with \doxylink{class_solo_menu}{Solo\+Menu}. \doxylink{class_solo_menu}{Solo\+Menu} will track screen touches by the user, checking to see if one of the registered buttons has been pressed. Once a button is pressed, the buttons callback function is called.

Low level functions that drive the TFT/\+LT7683 graphics chip are contained within \doxylink{namespace_t_f_t_m070_a1}{TFTM070\+A1} class. This is a slight repackaging of the low level functions provided by \href{https://www.buydisplay.com/}{\texttt{ Buy\+Display.\+com}} for use with their \href{https://dvititoe.github.io/Solo_Controller/html/docs/ER-TFT070A2-6-5633_Datasheet.pdf}{\texttt{ ER-\/\+TFT070\+A2-\/6-\/5633}} TFT. The Solo\+Canvas class provides higher level TFT/\+RAM management functionality. The menu objects use Solo\+Canvas to load, display, and manipulate imagery stored in TFT RAM. This insulates the menu classes from the lower-\/level graphics display details. Instead, the only need to interact with the simpler interface provided by Solo\+Canvas.

Each menu consists of\+:


\begin{DoxyItemize}
\item Background imagery, which is stored managed by a Solo\+Canvas object
\item Dynamic text, provided by the \doxylink{class_dynamic_text}{Dynamic\+Text} and \doxylink{class_text_box}{Text\+Box} objects
\item Buttons, provided by the various button classes shown in the following diagram
\end{DoxyItemize}

\begin{center}\end{center} 

The base \doxylink{class_button}{Button} class handle core functionality such as graphics updates, button presses/releases, and initiation of callback functions. There are a number of derived button classes that provide buttons with slightly different behaviors\+:


\begin{DoxyItemize}
\item {\bfseries{\doxylink{class_toggle_button}{Toggle\+Button}}}\+: Has two States\+: on/off. Each state has it\textquotesingle{}s own callback function. The callback functions are called whenever the button is {\itshape pressed}. Examples\+: Pump on/off button and Alarm on/off button
\item {\bfseries{\doxylink{class_momentary_button}{Momentary\+Button}}}\+: Has two States\+: on/off. Each state has it\textquotesingle{}s own callback function. The "{}on"{} callback function is called whenever the button is {\itshape pressed}. The "{}off"{} callback function is called whenever the button is {\itshape released}. Examples\+: \doxylink{namespace_setup}{Setup} button on the main menu (\doxylink{namespace_setup}{Setup} menu appears after user releases the button).
\item {\bfseries{\doxylink{class_immediate_button}{Immediate\+Button}}}\+: Has a single state and a single callback function. The callback function is called whenever the button is {\itshape pressed}. Examples\+: Buttons that switch between setup menus
\item {\bfseries{\doxylink{class_text_box}{Text\+Box}}}\+: Dynamic text that is also an \doxylink{class_immediate_button}{Immediate\+Button}. When the button is pressed, the Data\+Entry dialog appears, giving users the ability to update/change numerical values. Example\+: Kettle set temperature.
\end{DoxyItemize}\hypertarget{_software__architecture_autotoc_md36}{}\doxysubsection{\texorpdfstring{Font Classes}{Font Classes}}\label{_software__architecture_autotoc_md36}
{\itshape {\bfseries{Future Section....}}}\hypertarget{_software__architecture_autotoc_md37}{}\doxysubsection{\texorpdfstring{Software Dependencies}{Software Dependencies}}\label{_software__architecture_autotoc_md37}
The following diagram shows the dependencies between the major c++ header and cpp files in the project. The goal with this analysis was to avoid circular dependencies and, where possible, eliminate unnecessary dependencies between files.

\begin{center}\end{center} 

Note that \doxylink{main_8cpp}{main.\+cpp} only uses {\itshape Task\+Manager\+IO.\+h} and {\itshape \doxylink{_tasks_8h}{Tasks.\+h}}. This means that \doxylink{main_8cpp}{Main.\+cpp} does not have access to the alarms, sensors, menus, and canvases used by the application. It only needs to understand how to schedule tasks with the Task\+Manager. The file that implements the Tasks, {\itshape \doxylink{_tasks_8cpp}{Tasks.\+cpp}}, is responsible for interacting with the alarms, sensors, and menu objects used by the app.

Common parameters, such as Arduino pin definitions, are contained within \doxylink{_common_8h}{Common.\+h}

{\itshape {\bfseries{TBD Section...}}}\+: Need to update this write-\/up once I finish updating the menu system. How does menu access data values? 